package generator

import (
	"bytes"
	_ "embed"
	"fmt"
	"go/format"
	"log"
	"text/template"
	"unicode"

	"github.com/4chain-ag/go-wallet-toolbox/tools/client-gen/extractor"
	"github.com/go-softwarelab/common/pkg/seq"
)

//go:embed client.tpl
var goCodeTemplate string

// Package gathers the details about original package and the target package for generated code.
type Package struct {
	Name             string
	OriginalName     string
	OriginalFullName string
	IsSamePackage    bool
}

// OriginalPkgImportStatement returns the import statement for the original package if the target package is different from the original package.
func (p *Package) OriginalPkgImportStatement() string {
	if p.IsSamePackage {
		return ""
	}
	return fmt.Sprintf(`import "%s"`, p.OriginalFullName)
}

// NewPackage creates a new Package instance.
func NewPackage(name string, originalName string, originalFullName string, isSamePackage bool) *Package {
	return &Package{
		Name:             name,
		OriginalName:     originalName,
		OriginalFullName: originalFullName,
		IsSamePackage:    isSamePackage,
	}
}

// Generate will generate client code and embed client.tpl file with it
func Generate(pkg *Package, interfaces []extractor.InterfaceInfo) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by client-gen; DO NOT EDIT.\n\n")

	allImports := seq.FlattenSlices(seq.Map(seq.FromSlice(interfaces), func(i extractor.InterfaceInfo) []extractor.Import {
		return i.Imports
	}))

	allImports = seq.UniqBy(allImports, func(i extractor.Import) string {
		return i.Path
	})

	data := struct {
		IsSamePackage bool
		Package       *Package
		FullPackage   string
		Interfaces    []extractor.InterfaceInfo
		Imports       []extractor.Import
	}{
		Package:    pkg,
		Interfaces: interfaces,
		Imports:    seq.Collect(allImports),
	}

	// Generate Go code using the template
	tmpl, err := template.New("gocode").
		Funcs(template.FuncMap{"printType": typePrinter(pkg)}).
		Parse(goCodeTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	err = tmpl.Execute(&buf, data)
	if err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	// Format the generated code
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Failed to format generated code: %v", err)
	}

	return formattedCode
}

func typePrinter(pkg *Package) func(string) string {
	if pkg.IsSamePackage {
		return func(typeName string) string {
			return typeName
		}
	}
	return func(typeName string) string {
		if typeName == "" {
			return typeName
		}

		star := ""

		if typeName[0] == '*' {
			star = "*"
			typeName = typeName[1:]
		}
		var result string
		if unicode.IsUpper(rune(typeName[0])) {
			result = fmt.Sprintf("%s%s.%s", star, pkg.OriginalName, typeName)
		} else {
			result = star + typeName
		}

		return result
	}

}
